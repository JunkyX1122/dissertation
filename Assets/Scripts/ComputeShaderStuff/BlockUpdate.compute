// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

int3 back_centre = {0, 0, -1};
int3 back_up = {0, 1, -1};
int3 back_down = {0, -1, -1};
int3 back_left = {-1, 0, -1};
int3 back_right = {1, 0, -1};
int3 back_up_left = {-1, 1, -1};
int3 back_up_right = {1, 1, -1};
int3 back_down_left = {-1, -1, -1};
int3 back_down_right = {1, -1, -1};

int3 middle_centre = {0, 0, 0}; // THE CELL
int3 middle_up = {0, 1, 0};
int3 middle_down = {0, -1, 0};
int3 middle_left = {-1, 0, 0};
int3 middle_right = {1, 0, 0};
int3 middle_up_left = {-1, 1, 0};
int3 middle_up_right = {1, 1, 0};
int3 middle_down_left = {-1, -1, 0};
int3 middle_down_right = {1, -1, 0};
    
int3 front_centre = {0, 0, 1};
int3 front_up = {0, 1, 1};
int3 front_down = {0, -1, 1};
int3 front_left = {-1, 0, 1};
int3 front_right = {1, 0, 1};
int3 front_up_left = {-1, 1, 1};
int3 front_up_right = {1, 1, 1};
int3 front_down_left = {-1, -1, 1};
int3 front_down_right = {1, -1, 1};





int worldWidth;
int worldHeight;
int worldLength;
int CalculateArrayIndex(int indx, int indy, int indz)
{
    int x = indx;
    int y = indy;
    int z = indz;
    int indexer = x + y * worldHeight + z * worldLength * worldLength;
    return indexer;
}

struct cell
{
    int3 Position;
    int Type;
    float3 Velocity;
    int Back;
    int Right;
    int Top;
    int Left;
    int Front;
    int Bottom;
};

RWStructuredBuffer<cell> cellsInput;
RWStructuredBuffer<cell> cellsOutput;
[numthreads(32,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    
    cell cell = cellsInput[id.x];
    /*
    if(cell_neighbours.indexVelocities[CalculateArrayIndex(int3(1,1+1,1))].y == -1)
    {
        cell_neighbours.indexType[middle] = 1;
        cell_neighbours.indexVelocities[middle] = int3(0,-1,0);
    }
    else if(cell_neighbours.indexType[CalculateArrayIndex(int3(1,0,1))].y == 0)
    {
        cell_neighbours.indexType[middle] = 0;
        cell_neighbours.indexVelocities[middle] = int3(0,0,0);
    }
    */
    /**/
    if(cell.Type==0)
    {
        if(cell.Position.y+1 < worldHeight)
        {
            if(cellsInput[id.x + CalculateArrayIndex(0,1,0)].Type == 1)
            {
                cell.Type = 1;
                cell.Back = 1;
                cell.Right = 1;
                cell.Top = 1;
                cell.Left = 1;
                cell.Front = 1;
                cell.Bottom = 1;
            }
        }
    }
    else if(cell.Type==1)
    {
        if(cell.Position.y-1 >= 0)
        {
            if(cellsInput[id.x + CalculateArrayIndex(0,-1,0)].Type == 0)
            {
                cell.Type = 0;
                cell.Type = 0;
                cell.Back = 0;
                cell.Right = 0;
                cell.Top = 0;
                cell.Left = 0;
                cell.Front = 0;
                cell.Bottom = 0;
            }
        }
    }
    
    //cell.Type = 1;
    
    
   
    /*
    if(id.x==0)
    {
        cell.Type = 1;
    }
    else
    {
        cell.Type = 0;
    }
    */
    cellsOutput[id.x] = cell;
}



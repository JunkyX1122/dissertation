// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

int3 back_centre = {0, 0, -1};
int3 back_up = {0, 1, -1};
int3 back_down = {0, -1, -1};
int3 back_left = {-1, 0, -1};
int3 back_right = {1, 0, -1};
int3 back_up_left = {-1, 1, -1};
int3 back_up_right = {1, 1, -1};
int3 back_down_left = {-1, -1, -1};
int3 back_down_right = {1, -1, -1};

int3 middle_centre = {0, 0, 0}; // THE CELL
int3 middle_up = {0, 1, 0};
int3 middle_down = {0, -1, 0};
int3 middle_left = {-1, 0, 0};
int3 middle_right = {1, 0, 0};
int3 middle_up_left = {-1, 1, 0};
int3 middle_up_right = {1, 1, 0};
int3 middle_down_left = {-1, -1, 0};
int3 middle_down_right = {1, -1, 0};
    
int3 front_centre = {0, 0, 1};
int3 front_up = {0, 1, 1};
int3 front_down = {0, -1, 1};
int3 front_left = {-1, 0, 1};
int3 front_right = {1, 0, 1};
int3 front_up_left = {-1, 1, 1};
int3 front_up_right = {1, 1, 1};
int3 front_down_left = {-1, -1, 1};
int3 front_down_right = {1, -1, 1};





int worldWidth;
int worldHeight;
int worldLength;
int CalculateArrayIndex(int indx, int indy, int indz)
{
    int x = indx;
    int y = indy;
    int z = indz;
    int indexer = x + y * worldHeight + z * worldLength * worldLength;
    return indexer;
}

struct cell
{
    int3 Position;
    int Type;
    float3 Velocity;
    int Back;
    int Right;
    int Top;
    int Left;
    int Front;
    int Bottom;
};

RWStructuredBuffer<cell> cellsInput;
RWStructuredBuffer<cell> cellsOutput;
[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    
    cell currentCell = cellsInput[id.x];
    
    /*
    if(cell_neighbours.indexVelocities[CalculateArrayIndex(int3(1,1+1,1))].y == -1)
    {
        cell_neighbours.indexType[middle] = 1;
        cell_neighbours.indexVelocities[middle] = int3(0,-1,0);
    }
    else if(cell_neighbours.indexType[CalculateArrayIndex(int3(1,0,1))].y == 0)
    {
        cell_neighbours.indexType[middle] = 0;
        cell_neighbours.indexVelocities[middle] = int3(0,0,0);
    }
    */
    

    
    if(currentCell.Type==2)
    {
        if(currentCell.Position.y-1 >= 0)
        {
            
            int testPos = CalculateArrayIndex(floor
                (currentCell.Velocity.x),
                floor(currentCell.Velocity.y),
                floor(currentCell.Velocity.z));
            cell targetCell = cellsInput[id.x + testPos];
            if(targetCell.Type == 0)
            {
                targetCell.Type = currentCell.Type;
                targetCell.Velocity = currentCell.Velocity;
                targetCell.Back = 1;
                targetCell.Right = 1;
                targetCell.Top = 1;
                targetCell.Left = 1;
                targetCell.Front = 1;
                targetCell.Bottom = 1;
                
                currentCell.Type = 0;
                currentCell.Velocity.x = 0;
                currentCell.Velocity.y = 0;
                currentCell.Velocity.z = 0;
                
                currentCell.Back = 0;
                currentCell.Right = 0;
                currentCell.Top = 0;
                currentCell.Left = 0;
                currentCell.Front = 0;
                currentCell.Bottom = 0;
                
                
                cellsOutput[id.x + testPos] = targetCell;
                cellsOutput[id.x] = currentCell;
                
            }
            
        }
        
    }
    
    //cell.Type = 1;
    
    
   
    /*
    if(id.x==0)
    {
        cell.Type = 1;
    }
    else
    {
        cell.Type = 0;
    }
    */
    
    
    
    
}


